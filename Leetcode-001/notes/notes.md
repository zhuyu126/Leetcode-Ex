# 两数之和 

题目描述见 [两数之和](https://leetcode-cn.com/problems/two-sum/)

## 常规方法(暴力解决)

### 解决思路

根据题目描述，不难想到for循环遍历的方法，通过遍历数组中的每一个数据`x`，找到数组中是否含有 `target-x`,同时遍历时需要注意的是每一个位于`x`之前的元素都已经和`x`匹配过，因此不需要再进行匹配。
而每一个元素不能被使用两次，所以我们只需要在 `x`后面的元素中寻找`target - x`。
[暴力解决代码](https://github.com/zhuyu126/Leetcode-Ex/blob/master/Leetcode-001/code/Solution1.java)

### 复杂度分析

- 时间复杂度：*O(N^2)*，其中 *N* 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。
- 空间复杂度：*O(1)*。

## 使用hash优化暴力解决

### 解决思路

在暴力解法中，我们能发现在遍历`target-x`时的开销过大，我们可以采用一个hash表的方式来快速的找到目标元素`target-x`是否在数组中，从而将查询目标数据的时间复杂度从*O(N)*降低到*O(1)*提高效率。这样创建一个哈希表，对于每一个 `x`，我们首先查询哈希表中是否存在 `target - x`，然后将 `x`插入到哈希表中，即可保证不会让 `x` 和自己匹配。

[hash优化代码](https://github.com/zhuyu126/Leetcode-Ex/blob/master/Leetcode-001/code/Solution2.java)

### 复杂度分析

* 时间复杂度：`O(N)`，其中`N`是数组中的元素数量。对于每一个元素`x`，我们可以`O(1)`地寻找`target - x`。

* 空间复杂度：`O(N)`，其中`N`是数组中的元素数量。主要为创建哈希表的开销。