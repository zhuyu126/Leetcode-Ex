# 两数相加
题目描述[两数相加](https://leetcode-cn.com/problems/add-two-numbers/)
## 模拟计算解法
### 解题思路
- 根据题目描述，我们可以知道两个链表都是逆序存储的，输出结果的链表同样是逆序存储的。这样我们不难想到对两个链表中同一位置的元素进行相加，通过遍历逐位相加得到结果。即两个链表当前位置的数字为`x`，`y`相加结果为`sum=x+y`
- 在遍历两个链表的过程中，难免会出现两个链表长度不一致的情况，此时我们可以通过在对较短链表前补0的方式使两链表长度一致。如：`572+15=572+015=587`。
- 在逐位相加计算的时候，我们也应当考虑上一位置进位的问题，并在该位置相加计算的结束后，对进位值进行更新。设进位值为`carry`,则相加结果应为`sum=x+y+carry`,新的进位值为`carry=sum>9?1:0`（采用三元表达式求新进位值，为不是采用`carry=sum/10`是为了减少一次运算从而提高效率）
- 两链表相加之后存储在新链表同一位置的数据元素值为`sum%10`。
- 在链表遍历相加结束后，若存在进位值为`1`，则因在新链表前添加节点，节点值为`1`，如：`75+25=100`。
- 对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。
### 解题代码
[两数相加解决代码](https://github.com/zhuyu126/Leetcode-Ex/blob/master/Leetcode-002/code/Solution.java)
### 复杂度分析
时间复杂度:`O(max(m,n))`，其中`m,n`为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要`O(1)`的时间。
空间复杂度：`O(max(m,n))`。结果链表的长度最多为较长链表的长度`+1`。

